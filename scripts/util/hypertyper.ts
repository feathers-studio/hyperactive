// hypertyper ⚡️

import { EvenUnion } from "./types.ts";

export const eol = "\n";

export const preamble = `
// This file was generated by a script.
// Do not manually edit this file.`.trim();

export function* id<T>(value: T) {
	yield value;
}

export function isGen(xs: any): xs is Iterable<unknown> {
	return xs && Symbol.iterator in xs && typeof xs[Symbol.iterator] === "function";
}

export function* flatten<T>(xs: Iterable<T | Iterable<T>>) {
	for (const x of xs)
		if (isGen(x)) yield* x;
		else yield x;
}

export function* flatMap<T, U>(xs: Iterable<T>, mapper: (x: T) => Iterable<U>): Iterable<U> {
	for (const x of xs) yield* mapper(x);
}

export function* map<T, U>(xs: Iterable<T>, mapper: (x: T) => U) {
	for (const x of xs) yield mapper(x);
}

export function* join<T, U>(xs: Iterable<T>, joiner: U) {
	const iter = xs[Symbol.iterator]();
	let curr = iter.next();
	yield curr.value;
	while ((curr = iter.next())) {
		if (curr.done) return;
		else yield joiner;
		yield curr.value;
	}
}

export function* concat<T>(...xs: Iterable<T>[]) {
	for (const x of xs) yield* x;
}

type ImportSpec = EvenUnion<{ imports: (string | [string, string])[] } & { default: string } & { all: string }>;

function* _imports(path: string, { imports, default: def, all }: ImportSpec) {
	yield "import";
	if (imports) {
		yield " { ";
		yield* join(
			map(imports, v => (typeof v === "string" ? v : `${v[0]} as ${v[1]}`)),
			", ",
		);
		yield " } ";
	} else if (def) yield def;
	else if (all) yield `* as ${all}`;
	yield `from "${path}"`;
}

export function* imports(path: string, spec: ImportSpec) {
	yield* statement(_imports(path, spec));
}

export function* exports(content: Generator<string>) {
	const first = content.next();
	yield `export ${first.value}`;
	yield* content;
}

export function* split(str: string, delimiter: string) {
	for (const part of str.split(delimiter)) yield part;
}

export function* decl(type: "const" | "let" | "var" | "type", name: string, content: string | Generator<string>) {
	const iter = typeof content === "string" ? id(content) : content;

	const first = iter.next().value as string;
	yield `${type} ${name} =${first.startsWith("\n") ? "" : " "}${first}`;
	yield* iter;
}

export function* constant(name: string, content: string | Generator<string>) {
	yield* decl("const", name, content);
}

export function* type(name: string, type: string | Generator<string>) {
	yield* decl("type", name, type);
}

export function* iface(name: string, type: string | Generator<string>) {
	const iter = typeof type === "string" ? id(type) : type;

	const first = iter.next().value as string;
	yield `interface ${name}${first.startsWith("\n") ? "" : " "}${first}`;
	yield* iter;
}

const docLineStart = " *";

export const docLine = (line: string) => {
	line = line.trim();
	if (!line) return docLineStart;

	line = line.replace(/<|>/g, s => ({ "<": "`<", ">": ">`" }[s as "<" | ">"]));
	if (line.startsWith("Note")) line = "> " + line;
	return docLineStart + " " + line;
};

type Prop = {
	prop: string;
	type: string | Prop[];
	desc?: string;
};

const indent = "\t";

export function* desc(desc: string) {
	yield "/**" + eol;
	for (const d of desc.split(eol)) yield docLine(d) + eol;
	yield " */" + eol;
}

export function see(href: string, title?: string) {
	return "@see {@link " + [href, title].filter(Boolean).join(" ") + "}";
}

const idRegex = /^(_|$|[a-zA-Z])(_|$|[a-zA-Z0-9])*$/;

export function* member(name: string, type: string | Generator<string>, level: number) {
	yield (idRegex.test(name) ? name : `["${name}"]`) + ": ";
	if (typeof type === "string") {
		yield type;
		yield ";";
	} else {
		yield* type;
		if (level > 1) yield ";";
	}
}

export function* struct(members: Prop[], level = 1) {
	yield "{" + eol;

	for (const { prop, type, desc: descr } of members) {
		const proptype = member(prop, Array.isArray(type) ? struct(type, 2) : type, level);
		if (descr) for (const l of desc(descr)) yield indent.repeat(level) + l;
		yield indent.repeat(level);
		yield* proptype;
		yield eol;
	}

	yield indent.repeat(level - 1);
	yield "}";
}

export function* union(list: Iterable<string>) {
	for (const item of list) yield `\n\t| ${item}`;
}

export function* withGeneric(generic: string, contents: Iterable<string>) {
	yield generic;
	yield "<";
	yield* contents;
	yield ">";
}

export function* statement(...lines: Iterable<string>[]) {
	for (const line of lines) yield* line;
	yield ";";
}

export function* program(...statements: (string | Iterable<string>)[]) {
	let first = true;
	for (const statement of statements) {
		if (first) first = false;
		else yield eol;
		if (typeof statement === "string") yield statement;
		else yield* statement;
		yield eol;
	}
}

async function writeAll(w: Deno.Writer, arr: Uint8Array) {
	let nwritten = 0;
	while (nwritten < arr.length) nwritten += await w.write(arr.subarray(nwritten));
}

const sleep = (t: number) => new Promise(r => setTimeout(r, t));

type Opts = { pause?: number };

export function collectString(program: Iterable<string>) {
	let output = "";
	for (const segment of program) output += segment;
	return output;
}

export async function writer(filename: string, program: Iterable<string>, opts: Opts = {}) {
	const writer = await Deno.open(filename, { write: true, create: true, truncate: true });

	const encoder = new TextEncoder();
	const encode = encoder.encode.bind(encoder);

	for (const segment of program) {
		if (opts.pause) await sleep(opts.pause);
		await writeAll(writer, encode(segment));
	}

	writer.close();
}
